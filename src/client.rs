use crate::packet::{Packet, PacketData, PacketType};
use crate::payload::{Payload, PayloadDecodeError};
use async_std::task::{self, JoinHandle};
use async_trait::async_trait;
use futures::channel::mpsc;
use futures::sink::SinkExt;
use futures::stream::StreamExt;
use futures::try_join;
use serde::{Deserialize, Serialize};

use std::fmt;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::SystemTime;

use log::{debug, error, info};

#[async_trait]
pub trait EventHandler {
    async fn on_connect(&mut self);

    async fn on_disconnect(&mut self);

    async fn on_message(&mut self, data: PacketData);
}

/// A struct generated by the [`sender`](struct.Client.html#method.sender) method
/// on the client, which can be used to emit messages to the engine.io server
/// that client is connected to.
pub struct Sender {
    write_channel: mpsc::UnboundedSender<Packet>,
}

pub struct Client {
    write_channel: mpsc::UnboundedSender<Packet>,
    join_task_handle: JoinHandle<Result<(), EIOError>>,
}

struct EngineIO {
    sid: String,
    base_url: String,
    ping_interval: u32,
    ping_timeout: u32,
    ping_received: AtomicBool,
}

#[derive(Serialize, Deserialize, Debug)]
#[allow(non_snake_case)]
struct OpenPacket {
    sid: String,
    upgrades: Vec<String>,
    pingInterval: u32,
    pingTimeout: u32,
}

#[derive(Debug)]
pub enum EIOError {
    /// An error with the underlying transport.
    Transport(String),
    /// A violation of the engine.io protocol.
    Protocol(String),
    /// An error to signal that no pong was
    /// received from the other end.
    PongNotReceived,
}

impl std::error::Error for EIOError {}

impl fmt::Display for EIOError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            EIOError::Transport(str_) => write!(f, "{}", str_),
            EIOError::Protocol(str_) => write!(f, "{}", str_),
            EIOError::PongNotReceived => write!(f, "Pong was not received"),
        }
    }
}

impl From<surf::Exception> for EIOError {
    fn from(err: surf::Exception) -> Self {
        Self::Transport(format!("{}", err))
    }
}

impl From<PayloadDecodeError> for EIOError {
    fn from(err: PayloadDecodeError) -> Self {
        Self::Protocol(format!("{}", err))
    }
}

impl Sender {
    pub async fn emit_str(&mut self, data: String) {
        self.emit(PacketData::Str(data)).await;
    }

    async fn emit(&mut self, data: PacketData) {
        info!("Emitting {:?}", data);
        self.write_channel
            .send(Packet::new(PacketType::Message, data))
            .await
            .unwrap();
    }
}

impl Client {
    pub async fn join(&mut self) -> Result<(), EIOError> {
        futures::join!(&mut self.join_task_handle).0?;
        Ok(())
    }

    pub async fn connect(
        url: &str,
        event_handler: impl EventHandler + Send + Sync + 'static,
    ) -> Result<Client, EIOError> {
        let connect_url = format!("{}?transport=polling&EIO=3", url);
        info!("Establishing connection to {}", connect_url);
        let bytes = surf::get(&connect_url).recv_bytes().await.unwrap();
        let payload = Payload::new(&bytes).unwrap();

        if let PacketData::Str(string) = payload.packets().first().unwrap().data() {
            let packet: OpenPacket = serde_json::from_str(string).unwrap();
            debug!("Spawning task, sid is {}", packet.sid);
            let (sender, receiver) = mpsc::unbounded();

            let join_task_handle = task::spawn(EngineIO::fire_up(
                packet,
                url.to_owned(),
                event_handler,
                sender.clone(),
                receiver,
            ));

            let eio_client = Client {
                write_channel: sender.clone(),
                join_task_handle,
            };

            Ok(eio_client)
        } else {
            panic!("expected string");
        }
    }

    pub async fn emit_str(&mut self, data: String) {
        self.emit(PacketData::Str(data)).await;
    }

    async fn emit(&mut self, data: PacketData) {
        info!("Emitting {:?}", data);
        self.write_channel
            .send(Packet::new(PacketType::Message, data))
            .await
            .unwrap();
    }

    pub fn sender(&mut self) -> Sender {
        Sender {
            write_channel: self.write_channel.clone(),
        }
    }
}

impl EngineIO {
    async fn fire_up(
        open_pkt: OpenPacket,
        base_url: String,
        mut event_handler: impl EventHandler + Send + Sync,
        write_channel: mpsc::UnboundedSender<Packet>,
        receiver: mpsc::UnboundedReceiver<Packet>,
    ) -> Result<(), EIOError> {
        let config = EngineIO {
            sid: open_pkt.sid,
            base_url: base_url.to_owned(),
            ping_interval: open_pkt.pingInterval,
            ping_timeout: open_pkt.pingTimeout,
            ping_received: AtomicBool::new(true),
        };

        let result = try_join!(
            (&config).poll_loop(&mut event_handler),
            (&config).ping_loop(write_channel),
            (&config).write_loop(receiver),
        );

        event_handler.on_disconnect().await;

        match result {
            Ok(_) => Ok(()),
            Err(err) => Err(err),
        }
    }

    // self: &Arc<ClientConfig> is not yet supported (#64325)
    fn get_url(&self) -> String {
        let time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap();
        format!(
            "{}?transport=polling&EIO=3&sid={}&t={}.{}",
            self.base_url,
            self.sid,
            time.as_secs(),
            time.subsec_nanos()
        )
    }

    async fn ping_loop(
        &self,
        mut write_channel: mpsc::UnboundedSender<Packet>,
    ) -> Result<(), EIOError> {
        let timeout = std::time::Duration::new((self.ping_timeout / 1000) as u64, 0);
        let interval = std::time::Duration::new(
            (self.ping_interval / 1000 - self.ping_timeout / 1000) as u64,
            0,
        );
        debug!("Interval {:?}, Timeout {:?}", interval, timeout);

        loop {
            write_channel
                .send(Packet::with_str(PacketType::Ping, "probe"))
                .await
                .unwrap();

            self.ping_received.store(false, Ordering::SeqCst);

            async_std::task::sleep(timeout).await;

            // We expect to have received a pong after this time
            if !self.ping_received.load(Ordering::SeqCst) {
                error!("Pong not received, aborting");
                return Err(EIOError::PongNotReceived);
            }

            async_std::task::sleep(interval).await;
        }
    }

    async fn poll_loop(
        &self,
        event_handler: &mut (impl EventHandler + Send + Sync),
    ) -> Result<(), EIOError> {
        // When the poll loop starts, we are connected
        event_handler.on_connect().await;

        loop {
            let url = Self::get_url(&self);
            debug!("Polling {}", url);

            let bytes = match surf::get(&url).recv_bytes().await {
                Ok(bytes) => bytes,
                Err(exc) => {
                    return Err(exc.into());
                }
            };

            let payload = Payload::new(&bytes)?;

            for packet in payload.into_packets() {
                debug!("Received {:?}", packet);
                Self::handle_packet(self, packet, event_handler).await;
            }
        }
    }

    async fn write_loop(
        &self,
        mut receiver: mpsc::UnboundedReceiver<Packet>,
    ) -> Result<(), EIOError> {
        while let Some(packet) = receiver.next().await {
            debug!("Sending {:?}", packet);
            let payload = Payload::from_packet(packet);
            let url = Self::get_url(&self);
            let _response = surf::post(&url).body_bytes(payload.encode_binary()).await;
        }
        debug!("Exit write loop");
        Ok(())
    }

    async fn handle_packet(
        &self,
        packet: Packet,
        event_handler: &mut (dyn EventHandler + Send + Sync),
    ) {
        match packet.packet_type() {
            PacketType::Pong => {
                self.ping_received.store(true, Ordering::SeqCst);
            }
            PacketType::Close => {
                event_handler.on_disconnect().await;
            }
            PacketType::Message => {
                event_handler.on_message(packet.into_data()).await;
            }
            PacketType::Noop => (),
            _ => {
                error!("Unexpected packet {:?}", packet);
            }
        }
    }
}
